# Magic Rental Shop Unity 게임 제작 파이프라인

## 1. 프로젝트 초기 설정 및 환경 구축

### 1.1 Unity 프로젝트 생성 및 기본 설정
- Unity 2022.3 LTS 버전 사용 권장
- 2D 템플릿으로 프로젝트 생성
- Project Settings 설정:
  - Company Name: 개발사명
  - Product Name: Magic Rental Shop
  - Version: 0.1.0
  - Target Platform: Android/iOS (모바일 우선)
- Player Settings 설정:
  - Orientation: Portrait (세로 모드)
  - UI Scaling Mode: Scale with Screen Size
  - Reference Resolution: 1080x1920
  - Match: 0.5 (Width/Height 균형)

### 1.2 폴더 구조 설정
문서의 아키텍처에 따라 다음 폴더 구조 생성:

```
Assets/
└── _Project/
    ├── Data/                           # ScriptableObject 에셋
    │   ├── GameConfig.asset
    │   └── StaticData/
    │       ├── Weapons/
    │       │   ├── Common/
    │       │   ├── Uncommon/
    │       │   ├── Rare/
    │       │   ├── Epic/
    │       │   └── Legendary/
    │       ├── Customers/
    │       │   ├── Common/
    │       │   ├── Uncommon/
    │       │   ├── Rare/
    │       │   ├── Epic/
    │       │   └── Legendary/
    │       ├── Dungeons/
    │       ├── Recipes/
    │       ├── Materials/
    │       └── Events/
    ├── Prefabs/
    │   └── UI/
    │       ├── Common/
    │       ├── Panels/
    │       │   ├── Morning/
    │       │   ├── Day/
    │       │   └── Night/
    │       └── ListItems/
    ├── Sprites/
    │   ├── UI/
    │   ├── Icons/
    │   ├── Weapons/
    │   ├── Characters/
    │   └── Dungeons/
    └── Scripts/
        ├── Core/
        ├── Data/
        │   ├── RuntimeInstances/
        │   └── StaticData/
        └── Systems/
            ├── Common/
            └── Phases/
```

### 1.3 개발 환경 및 툴 설정
- TextMeshPro 패키지 설치 및 설정
- Unity UI 패키지 확인
- JSON.NET 패키지 설치 (Newtonsoft.Json)
- Git 설정 (.gitignore 파일 생성)
- 코딩 규칙 설정:
  - 클래스: PascalCase
  - 메서드: PascalCase  
  - 변수: camelCase
  - 상수: UPPER_SNAKE_CASE

## 2. 데이터 시스템 구현

### 2.1 기본 열거형 및 구조체 정의
- Enums.cs 파일에 GamePhase, Grade, Element, InventoryMode 등 정의
- 게임 전반에서 사용할 기본 데이터 타입 설정

### 2.2 ScriptableObject 데이터 클래스 구현
다음 순서로 ScriptableObject 클래스들 구현:
1. **GameConfig.cs** - 게임 전역 설정 (Hero 시스템 + 월세 시스템 포함)
2. **WeaponData.cs** - 무기 정보 (속성, 등급, 가격 등)
3. **CustomerData.cs** - 고객 정보 (Hero 후보 포함)
4. **DungeonData.cs** - 던전 정보
5. **MaterialData.cs** - 재료 정보 (availableDungeonIDs 포함)
6. **RecipeData.cs** - 제작 레시피 정보
7. **DailyEventData.cs** - 일일 이벤트 정보

### 2.3 런타임 인스턴스 클래스 구현
다음 순서로 런타임 데이터 클래스들 구현:
1. **WeaponInstance.cs** - 무기 인스턴스 (강화 레벨 포함)
2. **MaterialInstance.cs** - 재료 인스턴스 (수량 관리)
3. **CustomerInstance.cs** - 고객 인스턴스 (레벨, 던전 배정)
4. **HeroInstance.cs** - Hero 인스턴스 (현재/획득 레벨 분리)
5. **HeroCollectionData.cs** - Hero 도감 데이터
6. **InjuredHeroData.cs** - Hero 부상 데이터
7. **AdventureInstance.cs** - 모험 진행 데이터 (Hero 플래그 포함)
8. **CraftingInstance.cs** - 제작 진행 데이터
9. **AdventureResultData.cs** - 모험 결과 데이터

### 2.4 PlayerData 구현
- 모든 동적 게임 상태를 포함하는 메인 데이터 클래스
- Hero 시스템 관련 필드들 포함
- JSON 직렬화 가능한 구조로 설계

## 3. 핵심 관리자 시스템 구현

### 3.1 DataManager 구현
- 모든 ScriptableObject 데이터를 Dictionary로 관리
- Resources 폴더에서 데이터 자동 로드
- 데이터 접근을 위한 Get 메서드들 제공
- Hero 도감용 전체 Customer 데이터 관리

### 3.2 GameController 구현
- 게임의 전체 흐름 관리 (아침→낮→밤)
- Hero 회복 처리 및 레벨업 관리
- 월세 관리 및 게임오버 처리
- 페이즈 전환 시 자동저장
- 이벤트 시스템으로 다른 시스템들과 통신

### 3.3 UIManager 구현
- 모든 UI 패널과 팝업의 중앙 관리
- 페이즈별 패널 전환 시스템
- AlertPopup, LoadingPopup 등 공통 팝업 관리
- Hero UI 및 판매 UI 관리
- 팝업 스택 관리로 계층화된 UI 지원

### 3.4 구현 우선순위
1. **DataManager** - 다른 모든 시스템의 기반
2. **GameController** - 게임 흐름의 핵심
3. **UIManager** - UI 시스템의 중앙 허브

### 3.5 테스트 및 검증
- 각 관리자의 싱글톤 패턴 정상 동작 확인
- 데이터 로드 및 Dictionary 구성 확인
- 페이즈 전환 및 이벤트 발생 테스트
- PlayerData 직렬화/역직렬화 테스트

## 4. 게임 로직 시스템 구현

### 4.1 계산 시스템 구현
다음 순서로 게임 핵심 계산 로직들 구현:

#### 4.1.1 SuccessRateCalculator.cs
- **기본 성공률 계산**: (고객레벨 / (고객레벨 + 던전레벨)) × 100
- **속성 상성 계산**: 고객vs던전, 무기vs던전 상성 보정
- **등급 보정 계산**: Customer와 Hero 구분된 등급 보정 적용
- **특수 보정**: Light/Dark 속성의 1.3배 보정
- **최종 성공률**: 모든 보정 적용 후 1~100% 제한

#### 4.1.2 HeroConversionCalculator.cs
- **기본 전환 확률**: Customer 등급별 기본 확률 (5% ~ 1%)
- **무기 등급 보정**: Common(-30%) ~ Legendary(+100%)
- **던전 등급 보정**: Common(-20%) ~ Legendary(+100%)
- **최종 확률 계산**: 기본 확률 × (1 + 보정값들) 공식

#### 4.1.3 RentCalculator.cs
- **월세 계산**: 현재 일수 × 100골드
- **납부일 관리**: 7일 주기 계산
- **경고 시스템**: 납부일 하루 전 확인
- **게임오버 판정**: 골드 부족 시 조건 확인

### 4.2 Hero 시스템 구현
Hero 관련 핵심 시스템들 구현:

#### 4.2.1 HeroManager.cs
- **Hero 수집 관리**: Customer → Hero 전환 처리
- **Hero 레벨 시스템**: 성공 시 레벨업, 현재/획득 레벨 분리
- **부상 시스템**: 실패 시 10일 부상, 회복 관리
- **잠금해제 관리**: 등급별 일수 제한 (10일, 20일, 30일, 40일, 50일)
- **도감 상태 관리**: 수집 상태 및 UI 동기화
- **가용성 확인**: 모험 가능한 Hero 목록 제공

#### 4.2.2 Hero 관련 데이터 클래스들
- **HeroCollectionData.cs**: 도감 수집 상태 (획득여부, 레벨정보, 획득날짜)
- **InjuredHeroData.cs**: 부상 정보 (부상날짜, 회복날짜)
- **HeroRewardCalculator.cs**: Hero 전용 보상 계산 (1.5배 골드, 추가 레벨업)
- **HeroPenaltyCalculator.cs**: Hero 전용 페널티 계산 (부상기간, 치료비)

### 4.3 경제 및 상점 시스템 구현

#### 4.3.1 WeaponShopController.cs
- **상점 무기 생성**: 일수별 등급 확률에 따른 무기 생성
- **가격 산정**: 기본가격 × 등급배율 × 일수보정
- **새로고침 시스템**: 1000골드로 목록 재생성, 구매 상태 초기화
- **구매 상태 관리**: 오늘 구매한 무기 추적

#### 4.3.2 BlacksmithController.cs
- **제작 시스템**: 재료 확인 및 제작 시작
- **제작 진행 관리**: 일수별 제작 완료 처리
- **동시 제작 지원**: 여러 무기 동시 제작 가능
- **완료 알림**: 제작 완료 시 UI 업데이트

#### 4.3.3 InventoryController.cs
- **인벤토리 관리**: 무기/재료 추가/제거
- **판매 시스템**: 무기 판매 (구매가의 50%)
- **모드별 동작**: Normal/Selection/Management 모드
- **용량 관리**: 최대 인벤토리 크기 확인

### 4.4 모험 시스템 구현

#### 4.4.1 AdventureController.cs
- **모험 시작**: Customer/Hero 모험 생성 및 관리
- **일수 처리**: 매일 남은 일수 차감
- **결과 계산**: 성공률 기반 성공/실패 판정
- **Hero 전환 처리**: 성공한 Customer의 Hero 전환 확률 계산
- **보상 지급**: 골드, 재료, 경험치 지급

#### 4.4.2 CustomerManager.cs
- **고객 생성**: 일수별 등급 확률에 따른 고객 생성
- **레벨 계산**: 진행일수 × 0.2 + 등급보정
- **던전 배정**: 고객 등급 기준 던전 등급 확률 계산
- **Hero 전환 시 제거**: Customer 풀에서 제거 처리

### 4.5 저장/로드 시스템 구현

#### 4.5.1 PersistenceController.cs
- **JSON 저장/로드**: PlayerData 전체 직렬화/역직렬화
- **자동저장**: 페이즈 전환 시마다 자동저장
- **백업 시스템**: 이전 저장 파일 백업 보관
- **Hero 승계**: 게임오버 후 Hero 데이터 승계 처리

#### 4.5.2 ID 변환 시스템
- **StaticData ID → 실제 데이터**: DataManager를 통한 변환
- **인스턴스 ID 관리**: 고유 ID로 인스턴스 추적
- **참조 무결성**: 저장/로드 시 데이터 일관성 보장

### 4.6 구현 우선순위
1. **계산 시스템** (SuccessRateCalculator, HeroConversionCalculator, RentCalculator)
2. **HeroManager** - Hero 시스템의 핵심
3. **AdventureController** - 게임의 메인 루프
4. **경제 시스템** (WeaponShop, Blacksmith, Inventory)
5. **PersistenceController** - 데이터 보존

## 5. UI 시스템 구현

### 5.1 공통 UI 컴포넌트 구현

#### 5.1.1 StatusBarView.cs
- **위치**: 페이즈 패널과 인벤토리 사이 (구분선 역할)
- **표시 정보**: 골드, 날짜, 페이즈, 남은 시간
- **자동 업데이트**: GameController 이벤트 구독으로 실시간 반영
- **레이아웃**: 최대한 얇은 바 형태로 공간 효율성 극대화

#### 5.1.2 InventoryView.cs
- **모드 시스템**: Normal/Selection/Management 모드별 동작
- **탭 구조**: 무기 탭과 재료 탭 분리
- **페이지네이션**: GameConfig.uiPageSize에 따른 페이지 분할
- **판매 기능**: Management 모드에서 무기 판매 버튼 표시
- **선택 강조**: Selection 모드에서 선택 가능한 무기 하이라이트

#### 5.1.3 공통 팝업 시스템
- **AlertPopup**: 제목, 메시지, 확인 버튼만 있는 단순 알림
- **LoadingPopup**: 회전 아이콘과 로딩 메시지
- **SellWeaponPanel**: 무기 판매 확인 (가격 표시 포함)
- **팝업 스택**: UIManager에서 계층화된 팝업 관리

### 5.2 페이즈별 UI 패널 구현

#### 5.2.1 아침 페이즈 UI (Morning)
**MorningView.cs**:
- **메인 버튼들**: 무기상점, 대장간, 이벤트확인 버튼
- **월세 경고**: 납부일 하루 전 자동 AlertPopup 표시

**WeaponShopPanel.cs**:
- **무기 목록**: BuyWeaponButton들의 페이지네이션
- **새로고침 버튼**: 우상단에 1000골드 비용으로 목록 재생성
- **구매 상태**: 구매한 무기는 회색 처리, 클릭 불가

**BlacksmithPanel.cs**:
- **상단 영역**: 레시피 버튼들 (3/5 비율)
- **하단 영역**: 제작 현황 표시 (2/5 비율, 인벤토리 영역 활용)
- **제작 완료**: 체크 표시 → 클릭하여 무기 획득

#### 5.2.2 낮 페이즈 UI (Day)
**DayView.cs**:
- **고객 목록**: CustomerButton들의 페이지네이션
- **Hero 메뉴**: Hero 도감과 Hero 모험 진입 버튼

**CustomerInfoPanel.cs**:
- **상단 정보**: 고객 상세 정보 (7/10 비율)
- **하단 선택**: 던전 아이콘, 무기 아이콘 (3/10 비율)
- **무기 선택**: 인벤토리 최상위 레이어로 이동

**Hero 시스템 UI**:
- **HeroMenuPanel**: 도감과 모험 선택
- **HeroCollectionPanel**: 그림자/실제 아이콘으로 수집 상태 표시
- **HeroListPanel**: CustomerListPanel과 동일한 구조, 부상 상태 표시

#### 5.2.3 밤 페이즈 UI (Night)
**NightView.cs**:
- **진행중 모험**: Customer 우선, Hero 구분 표시
- **완료된 모험**: Customer 결과 먼저, Hero 결과 나중
- **다음 날 버튼**: 모든 결과 확인 후 활성화

**AdventureInfoPanel.cs**:
- **Customer/Hero 통합**: 동일한 패널에 Hero는 별표(★) 구분
- **정렬 규칙**: Customer 모험들 → Hero 모험들

**ResultInfoPanel.cs**:
- **성공/실패 표시**: O/X 아이콘으로 명확한 결과 표시
- **Hero 전환**: Customer가 Hero로 전환된 경우 특별 표시
- **Hero 레벨업**: Hero 성공 시 레벨업 표시 (25 → 26)

### 5.3 동적 생성 UI 아이템들

#### 5.3.1 리스트 아이템 컴포넌트들
- **CustomerButton/HeroButton**: 고객/Hero 개별 아이템
- **WeaponButton**: 무기 아이템 (판매 버튼 포함)
- **MaterialButton**: 재료 아이템 (수량 표시)
- **RecipeButton**: 레시피 아이템
- **CraftingWeaponButton**: 제작중/완료 무기 아이템

#### 5.3.2 상태별 UI 처리
- **잠금 상태**: Hero 잠금해제 조건 미달 시 회색 처리
- **부상 상태**: Hero 부상 시 회색 + "X일 남음" 표시
- **완료 상태**: 제작 완료 시 체크 아이콘 오버레이

### 5.4 UI 레이아웃 시스템

#### 5.4.1 3:2 공통 레이아웃
```
┌─────────────────────────────────────┐
│                                     │ ← 3/5 비율
│      현재 페이즈 패널 영역           │   (메인 컨텐츠)
│                                     │
├─────────────────────────────────────┤
│ StatusBar (구분선)                  │ ← 얇은 바
├─────────────────────────────────────┤
│        InventoryView                │ ← 2/5 비율
└─────────────────────────────────────┘
```

#### 5.4.2 모바일 최적화
- **터치 영역**: 최소 44pt 이상 확보
- **폰트 크기**: 최소 16pt 이상으로 가독성 보장
- **스크롤**: 긴 리스트는 스크롤 또는 페이지네이션
- **원터치 조작**: 모든 상호작용을 한 번의 터치로 해결

### 5.5 UI 애니메이션 시스템

#### 5.5.1 전환 애니메이션
- **페이즈 전환**: 페이드 인/아웃 효과
- **팝업 등장**: 스케일 애니메이션
- **버튼 클릭**: 스케일 다운/업 피드백
- **Hero 전환**: 특별한 반짝임 효과

#### 5.5.2 상태 애니메이션
- **골드 변화**: 숫자 카운팅 애니메이션
- **레벨업**: Hero 레벨업 시 특수 효과
- **부상 회복**: 회복 완료 시 치유 효과
- **제작 완료**: 체크 아이콘 등장 애니메이션

### 5.6 UI 구현 우선순위
1. **공통 UI** (StatusBar, InventoryView)
2. **기본 팝업** (AlertPopup, LoadingPopup)
3. **페이즈 UI** (Morning → Day → Night 순서)
4. **Hero 시스템 UI**
5. **애니메이션 및 시각 효과**

## 6. 게임 콘텐츠 데이터 생성

### 6.1 정적 데이터 생성 계획

#### 6.1.1 무기 데이터 생성
**등급별 무기 개수**:
- Common: 20개 (다양한 기본 무기)
- Uncommon: 15개 (향상된 기본 무기)
- Rare: 12개 (특수 무기)
- Epic: 8개 (강력한 특수 무기)
- Legendary: 5개 (최고급 무기, 2개 속성)

**속성별 분배**:
- Fire, Water, Earth, Air, Thunder, Ice: 각 속성별 균등 분배
- Light, Dark: 각각 전체의 10% 정도로 희소성 유지

**가격 체계**:
- Common: 500~1,000골드
- Uncommon: 800~1,500골드
- Rare: 1,200~2,500골드
- Epic: 2,000~5,000골드
- Legendary: 5,000~10,000골드

#### 6.1.2 고객 데이터 생성
**등급별 고객 개수**:
- Common: 25개 (기본 모험가들)
- Uncommon: 20개 (숙련된 모험가들)
- Rare: 15개 (유명한 모험가들)
- Epic: 10개 (전설적인 인물들)
- Legendary: 5개 (신화급 존재들)

**Hero 전환 시 고려사항**:
- 각 고객마다 Hero 아이콘 별도 준비
- Hero 전환 시 특수 능력 설정 (추후 구현)
- 백스토리와 설명 텍스트 작성

#### 6.1.3 던전 데이터 생성
**등급별 던전 개수**:
- Common: 15개 (초보자 던전)
- Uncommon: 12개 (중급자 던전)
- Rare: 10개 (고급자 던전)
- Epic: 8개 (전문가 던전)
- Legendary: 5개 (최고난이도 던전)

**던전 테마**:
- 자연계: 숲, 동굴, 산, 사막
- 건축물: 성, 탑, 유적, 지하도시
- 환상계: 마계, 천계, 이차원
- 특수: 시간의 틈, 꿈의 세계

### 6.2 ScriptableObject 에셋 생성

#### 6.2.1 GameConfig 설정
```
Assets/_Project/Data/GameConfig.asset 생성:
- 기본 게임 설정값들
- Hero 시스템 설정값들
- 경제 시스템 설정값들
- UI 설정값들
```

#### 6.2.2 데이터 에셋 생성 방법
**자동 생성 에디터 툴**:
- CSV 파일에서 ScriptableObject 자동 생성
- 일괄 ID 생성 및 검증
- 아이콘 자동 할당 시스템
- 데이터 무결성 검사 툴

**수동 생성 가이드라인**:
- ID 네이밍 규칙: Type_Name_Grade (예: Weapon_IronSword_Common)
- 폴더별 정리: 등급별 하위 폴더로 체계적 관리
- 아이콘 연결: 같은 이름의 스프라이트 자동 매칭

### 6.3 재료 및 제작 시스템 데이터

#### 6.3.1 재료 데이터
**기본 재료** (Common):
- 철광석, 구리, 나무, 가죽, 천
- 각 던전에서 획득 가능한 재료 설정

**고급 재료** (Rare~Legendary):
- 용의 비늘, 미스릴, 다이아몬드, 별의 조각
- 특정 고난이도 던전에서만 획득

**재료-던전 연결**:
- MaterialData.availableDungeonIDs 활용
- 재료별로 얻을 수 있는 던전 목록 설정
- 희귀도에 따른 획득 난이도 조절

#### 6.3.2 레시피 데이터
**레시피 구성**:
- 필요 재료 2~5개
- 제작 비용 (골드)
- 제작 시간 (일수)
- 결과 무기

**등급별 레시피**:
- Common: 기본 재료 2~3개
- Uncommon: 기본 재료 3~4개
- Rare: 기본 재료 + 고급 재료 1개
- Epic: 고급 재료 2~3개
- Legendary: 최고급 재료 3~5개

### 6.4 밸런스 조정용 데이터

#### 6.4.1 성공률 테스트 데이터
**시나리오별 성공률 계산**:
- 같은 등급: 약 50% 성공률 목표
- 1등급 차이: 30~70% 범위
- 속성 유리: +20~30% 보정
- Hero 보정: 일반 고객 대비 강화

#### 6.4.2 경제 밸런스 데이터
**골드 흐름 분석**:
- 무기 구매 비용 vs 모험 보상
- 월세 증가 vs 수입 증가
- 무기 판매 수익성
- Hero 전환율과 장기 수익성

#### 6.4.3 진행도별 난이도 곡선
**일수별 목표 설정**:
- 1~10일: 튜토리얼 및 기본 시스템 익히기
- 11~30일: Hero 시스템 도입 및 확장
- 31~50일: 고급 컨텐츠 및 전략적 플레이
- 51일 이후: 도전적인 생존 플레이

### 6.5 테스트 데이터 및 검증

#### 6.5.1 최소 동작 데이터셋
**프로토타입용 최소 데이터**:
- 각 등급별 무기 2개씩 (총 10개)
- 각 등급별 고객 2개씩 (총 10개)
- 각 등급별 던전 1개씩 (총 5개)
- 기본 재료 5개, 기본 레시피 3개

#### 6.5.2 데이터 검증 시스템
**자동 검증 항목**:
- ID 중복 확인
- 참조 무결성 확인 (재료→던전 연결 등)
- 밸런스 수치 범위 확인
- 필수 필드 누락 확인

#### 6.5.3 플레이테스트 데이터
**시나리오별 테스트 케이스**:
- 첫 Hero 획득까지의 시간
- 월세 납부 압박 정도
- 무기 제작 vs 구매 효율성
- Hero 부상 시스템의 체감 밸런스

### 6.6 데이터 생성 우선순위
1. **최소 동작 데이터셋** - 프로토타입 테스트용
2. **핵심 게임플레이 데이터** - 기본 루프 완성용
3. **Hero 시스템 데이터** - Hero 관련 모든 데이터
4. **밸런스 조정 데이터** - 플레이테스트 결과 반영
5. **최종 컨텐츠 데이터** - 모든 무기, 고객, 던전 완성

## 7. 통합 테스트 및 디버깅

### 7.1 시스템 간 연동 테스트

#### 7.1.1 게임 플로우 통합 테스트
**전체 게임 루프 검증**:
- 아침→낮→밤 페이즈 전환의 완전성
- 각 페이즈에서 UI 정상 동작 확인
- 페이즈 전환 시 데이터 보존 및 자동저장
- 시간 제한과 다음 페이즈 버튼 동작

**데이터 흐름 검증**:
- PlayerData 업데이트가 모든 UI에 즉시 반영
- 골드 변화 시 StatusBar 자동 업데이트
- 인벤토리 변화 시 관련 UI 동기화
- 이벤트 시스템을 통한 시스템 간 통신

#### 7.1.2 모험 시스템 통합 테스트
**모험 생성부터 완료까지**:
- 고객 선택 → 무기 장착 → 모험 시작
- 일수 경과에 따른 모험 진행 상태 업데이트
- 모험 완료 시 결과 계산 및 보상 지급
- Hero 전환 및 레벨업 처리 정확성

**Customer/Hero 구분 처리**:
- Customer와 Hero의 서로 다른 성공률 계산
- Hero 전용 보상 시스템 동작
- Hero 실패 시 부상 시스템 처리
- UI에서 Customer/Hero 구분 표시 정확성

#### 7.1.3 경제 시스템 통합 테스트
**골드 흐름 추적**:
- 무기 구매/판매 시 골드 변화 정확성
- 모험 성공 시 보상 골드 지급
- 월세 납부 시 골드 차감 및 게임오버 처리
- 제작 비용 및 새로고침 비용 처리

**인벤토리 연동**:
- 무기 구매 시 인벤토리 추가
- 무기 대여 시 사용 불가 상태 처리
- 무기 판매 시 인벤토리에서 제거
- 재료 획득 및 소모 정확성

### 7.2 Hero 시스템 통합 테스트

#### 7.2.1 Hero 전환 시스템 검증
**전환 프로세스 전체**:
- 모험 성공 → 전환 확률 계산 → 실제 전환
- Customer 풀에서 제거 → Hero 풀에 추가
- Hero 도감 상태 업데이트 (그림자 → 실제 아이콘)
- PlayerData의 모든 Hero 관련 필드 동기화

**확률 계산 정확성**:
- 기본 확률 + 무기 보정 + 던전 보정 공식 검증
- 등급별 확률 차이 체감 테스트
- 극단적 케이스 (0%, 100% 근접) 처리

#### 7.2.2 Hero 부상 시스템 검증
**부상 처리 전과정**:
- Hero 모험 실패 → 10일 부상 처리
- InjuredHeroData 생성 및 관리
- UI에서 부상 상태 표시 (회색 처리, 타이머)
- 매일 회복 상태 확인 및 정상 복귀

**Hero 레벨 시스템**:
- 모험 성공 시 레벨업 처리
- 현재 레벨과 획득 레벨 분리 관리
- 최대 레벨 제한 (100레벨) 처리
- UI에서 레벨 정보 정확한 표시

#### 7.2.3 Hero 잠금해제 시스템 검증
**등급별 잠금해제**:
- 10일, 20일, 30일, 40일, 50일 잠금해제 타이밍
- 잠금된 Hero UI에서 비활성화 처리
- 해금 시 즉시 UI 활성화 및 사용 가능
- 새 게임 시 잠금 상태 초기화

### 7.3 데이터 무결성 검증

#### 7.3.1 저장/로드 시스템 검증
**저장 정확성**:
- 모든 PlayerData 필드 누락 없이 저장
- Hero 관련 복합 데이터 구조 정확한 직렬화
- ID 참조 관계 보존 (WeaponInstance → WeaponData)
- 특수 케이스 (빈 리스트, null 값) 처리

**로드 정확성**:
- 저장된 상태와 동일하게 복원
- ID를 통한 StaticData 참조 복원
- Hero 도감 상태 정확한 복원
- 부상 Hero 상태 및 타이머 복원

#### 7.3.2 에러 처리 및 예외 상황
**데이터 손상 대응**:
- 잘못된 ID 참조 시 기본값 설정
- 저장 파일 손상 시 새 게임 유도
- 메모리 부족 시 안전한 종료
- 네트워크 오류 시 로컬 저장 유지

### 7.4 성능 및 메모리 테스트

#### 7.4.1 메모리 사용량 모니터링
**시스템별 메모리 사용**:
- DataManager의 Dictionary 메모리 사용량
- UI 프리팹 인스턴스화 메모리 오버헤드
- Hero 데이터 증가에 따른 메모리 변화
- 장시간 플레이 시 메모리 누수 여부

#### 7.4.2 프레임레이트 최적화
**UI 업데이트 최적화**:
- StatusBar 실시간 업데이트 성능
- 인벤토리 페이지네이션 스크롤 성능
- Hero 리스트 대량 표시 시 성능
- 팝업 생성/제거 시 프레임 드롭 최소화

### 7.5 디버깅 도구 및 테스트 환경

#### 7.5.1 개발자 디버그 UI
**실시간 데이터 모니터링**:
- 현재 PlayerData 상태 실시간 표시
- Hero 전환 확률 실시간 계산 결과
- 성공률 계산 과정 단계별 표시
- 메모리 사용량 및 성능 지표

**치트 기능** (개발용):
- 골드 임의 추가/차감
- 특정 Hero 강제 획득
- 시간 빨리감기 (일수 증가)
- 특정 시나리오 강제 발생

#### 7.5.2 자동화된 테스트 시나리오
**회귀 테스트 스위트**:
- 기본 게임 플로우 자동 실행
- Hero 전환 확률 통계적 검증
- 경제 시스템 밸런스 검증
- 저장/로드 정확성 반복 테스트

## 8. UI/UX 최적화 및 모바일 최적화

### 8.1 모바일 UI 최적화

#### 8.1.1 터치 인터랙션 최적화
**터치 영역 설계**:
- 최소 44pt 터치 영역 보장
- 버튼 간 8pt 이상 간격 유지
- 스크롤 영역과 버튼 영역 분리
- 실수 터치 방지를 위한 확인 단계

**제스처 지원**:
- 인벤토리 스와이프로 탭 전환
- 긴 리스트 스크롤 관성 구현
- 팝업 영역 외 터치로 닫기
- 뒤로가기 버튼 대응

#### 8.1.2 반응형 레이아웃
**다양한 해상도 대응**:
- 16:9, 18:9, 19.5:9 비율 지원
- Safe Area를 고려한 UI 배치
- 폰트 크기 기기별 자동 조정
- 아이콘 크기 DPI별 최적화

**방향 전환 대응**:
- 세로 모드 전용 고정
- 가로 모드 진입 시 안내 메시지
- 화면 회전 시 레이아웃 유지

#### 8.1.3 성능 최적화
**UI 렌더링 최적화**:
- UI 요소 적절한 Batching
- 불필요한 Raycast 최소화
- 스크롤 뷰 셀 재활용 패턴
- 비활성 UI 요소 비활성화

**메모리 최적화**:
- 텍스처 압축 및 해상도 조정
- 사용하지 않는 프리팹 언로드
- 오디오 클립 압축 설정
- 가비지 컬렉션 최소화

### 8.2 사용자 경험 개선

#### 8.2.1 직관적인 UI 디자인
**정보 계층 구조**:
- 중요한 정보 (골드, 시간) 항상 표시
- 액션 버튼 명확한 위치 배치
- 상태 정보 시각적 구분 (색상, 아이콘)
- 진행 상황 명확한 피드백

**색상 및 아이콘 시스템**:
- 등급별 일관된 색상 체계
- 속성별 구분 가능한 색상
- 상태별 직관적인 아이콘 (성공/실패, 잠금/해제)
- 접근성을 고려한 색맹 대응

#### 8.2.2 피드백 시스템
**즉시 피드백**:
- 버튼 터치 시 즉각적인 시각/촉각 피드백
- 골드 변화 시 애니메이션 효과
- 중요한 이벤트 (Hero 획득) 특별 효과
- 오류 상황 명확한 안내 메시지

**진행 상황 안내**:
- 로딩 중 진행률 표시
- 제작 진행 상황 실시간 업데이트
- 모험 남은 일수 직관적 표시
- 목표 달성도 시각화

#### 8.2.3 학습 곡선 최적화
**튜토리얼 시스템**:
- 첫 실행 시 기본 조작 안내
- 새 기능 해금 시 설명 팝업
- Hero 시스템 첫 체험 시 가이드
- 복잡한 기능의 단계별 학습

**도움말 시스템**:
- 각 화면별 ? 버튼으로 설명 접근
- 게임 용어 사전 제공
- 성공률 계산 방식 상세 설명
- FAQ 및 팁 모음

### 8.3 접근성 및 포용성

#### 8.3.1 시각 접근성
**색각 이상 대응**:
- 색상만으로 정보 구분 금지
- 패턴, 모양, 텍스트로 보완
- 고대비 모드 지원
- 색상 조합 접근성 검증

**시각 장애 대응**:
- 적절한 폰트 크기 및 대비
- 중요한 UI 요소 큰 크기
- 텍스트 읽기 쉬운 폰트 선택
- 화면 확대 기능 고려

#### 8.3.2 조작 접근성
**운동 능력 고려**:
- 한 손 조작 가능한 UI 배치
- 정밀한 조작 요구하지 않는 설계
- 길게 누르기 대신 탭 우선 사용
- 실수 방지 및 되돌리기 기능

### 8.4 최적화 검증 및 테스트

#### 8.4.1 다양한 기기 테스트
**성능 테스트 기기군**:
- 저사양 기기 (RAM 2GB 이하)
- 중간 사양 기기 (RAM 4GB)
- 고사양 기기 (RAM 8GB 이상)
- 다양한 화면 비율 기기

**성능 지표 모니터링**:
- 평균 프레임레이트 60fps 유지
- 메모리 사용량 적정 수준 유지
- 배터리 소모량 측정
- 발열 현상 모니터링

#### 8.4.2 사용성 테스트
**실제 사용자 테스트**:
- 첫 플레이 사용자 관찰
- 기능 발견 가능성 측정
- 오조작 빈도 및 원인 분석
- 만족도 및 재플레이 의도 조사

## 9. 사운드 및 비주얼 이펙트

### 9.1 사운드 시스템 구현

#### 9.1.1 오디오 아키텍처 설계
**AudioManager 시스템**:
- BGM, SFX, UI 사운드 분리 관리
- 볼륨 조절 기능 (마스터, BGM, SFX)
- 사운드 풀링으로 메모리 최적화
- 백그라운드 진입 시 음소거

**오디오 압축 및 최적화**:
- BGM: OGG 압축으로 용량 최소화
- SFX: WAV 비압축으로 지연시간 최소화
- 모바일 최적화 비트레이트 설정
- 스트리밍 vs 메모리 로드 전략

#### 9.1.2 게임 내 사운드 요소
**BGM 구성**:
- 메인 테마: 판타지 분위기의 경쾌한 멜로디
- 아침 페이즈: 활기찬 상점가 분위기
- 낮 페이즈: 모험 준비의 긴장감
- 밤 페이즈: 모험 결과의 드라마틱함
- Hero 테마: 특별한 순간의 웅장한 음악

**효과음 (SFX)**:
- 골드 획득: 동전 소리 (양에 따라 길이 조절)
- 무기 장착: 금속 클링 소리
- 모험 성공: 승리 팡파레
- 모험 실패: 어두운 분위기 사운드
- Hero 전환: 특별한 변환 마법 소리

**UI 사운드**:
- 버튼 클릭: 가벼운 클릭음
- 페이지 전환: 부드러운 스와이프 소리
- 팝업 등장: 알림 벨 소리
- 오류 알림: 부드러운 경고음
- 중요 알림: 특별한 차임 소리

#### 9.1.3 적응형 오디오 시스템
**상황별 음악 변화**:
- 골드 부족 시 긴장감 있는 음악으로 변화
- Hero 획득 시 감동적인 음악으로 전환
- 월세 경고 시 시계 틱톡 소리 추가
- 게임오버 임박 시 드라마틱한 음악

**오디오 설정 옵션**:
- 마스터 볼륨 조절 (0~100%)
- BGM/SFX 개별 볼륨 조절
- 진동 피드백 ON/OFF
- 백그라운드 음악 재생 여부

### 9.2 비주얼 이펙트 시스템

#### 9.2.1 파티클 시스템 구현
**VFXManager 시스템**:
- 파티클 이펙트 중앙 관리
- 오브젝트 풀링으로 성능 최적화
- 화면에 동시 표시되는 이펙트 수 제한
- 저사양 기기 옵션으로 이펙트 품질 조절

**핵심 비주얼 이펙트**:
- 골드 획득: 동전이 떨어지는 파티클
- Hero 전환: 마법진과 빛의 기둥 효과
- 레벨업: 별빛이 터지는 효과
- 모험 성공: 승리의 빛 폭발
- 제작 완료: 반짝이는 완성 효과

#### 9.2.2 UI 애니메이션 고도화
**전환 애니메이션**:
- 페이즈 전환: 페이드 인/아웃 + 슬라이드
- 패널 등장: 스케일 업 + 이징 효과
- 버튼 피드백: 스케일 다운/업 + 컬러 변화
- 리스트 아이템: 순차적 등장 애니메이션

**상태 변화 애니메이션**:
- 골드 변화: 숫자 카운팅 + 색상 변화
- HP/상태 변화: 부드러운 바 애니메이션
- 잠금 해제: 자물쇠 열리는 애니메이션
- 부상 회복: 치유 빛 효과

#### 9.2.3 특별 이벤트 연출
**Hero 관련 특수 연출**:
- Hero 전환 순간: 화면 전체 특수 효과
- 첫 Hero 획득: 튜토리얼과 축하 연출
- Legendary Hero 획득: 최고급 축하 연출
- Hero 레벨업: 성장 실감할 수 있는 효과

**중요 순간 강조 연출**:
- 월세 납부 성공: 안도감 표현 연출
- 게임오버 회피: 간신히 생존한 드라마
- 대박 모험 성공: 특별한 승리 연출
- 희귀 아이템 획득: 발견의 기쁨 표현

### 9.3 최적화 및 성능 고려사항

#### 9.3.1 모바일 성능 최적화
**이펙트 LOD 시스템**:
- 기기 성능에 따른 이펙트 품질 자동 조절
- 저사양: 간단한 색상 변화만
- 중간: 기본 파티클 효과
- 고사양: 모든 고급 이펙트 활성화

**배터리 절약 모드**:
- 장시간 플레이 시 이펙트 자동 감소
- 배터리 잔량에 따른 성능 조절
- 사용자 설정으로 절약 모드 수동 활성화

#### 9.3.2 메모리 및 용량 관리
**오디오 최적화**:
- 동적 로딩으로 메모리 사용량 최소화
- 압축률과 품질의 균형점 찾기
- 미사용 오디오 클립 자동 언로드

**이펙트 최적화**:
- 텍스처 아틀라스로 드로우콜 최소화
- 간단한 셰이더 사용으로 GPU 부하 감소
- 화면 밖 이펙트 자동 정리

### 9.4 구현 우선순위 및 단계

#### 9.4.1 1단계: 핵심 오디오
- AudioManager 기본 구조
- 필수 UI 사운드 (클릭, 알림)
- 기본 BGM (메인 테마 1곡)

#### 9.4.2 2단계: 기본 이펙트
- 골드 변화 애니메이션
- 기본 UI 전환 애니메이션
- 간단한 파티클 효과

#### 9.4.3 3단계: Hero 시스템 특화
- Hero 전환 특수 연출
- Hero 관련 사운드 및 이펙트
- 레벨업 및 성장 연출

#### 9.4.4 4단계: 고급 연출
- 페이즈별 BGM 분화
- 복잡한 파티클 시스템
- 상황별 적응형 오디오

## 10. 최종 빌드 및 배포 준비

### 10.1 빌드 최적화

#### 10.1.1 코드 최적화
**성능 최적화**:
- 불필요한 Update() 호출 제거
- 코루틴을 활용한 비동기 처리
- 오브젝트 풀링 패턴 적용
- 가비지 컬렉션 최소화 코딩

**메모리 최적화**:
- 텍스처 압축 설정 최적화
- 사용하지 않는 에셋 제거
- Resources.UnloadUnusedAssets() 적절한 호출
- 메모리 누수 지점 제거

#### 10.1.2 에셋 최적화
**텍스처 최적화**:
- 플랫폼별 최적 압축 포맷 사용
- 해상도별 텍스처 준비 (1x, 2x, 3x)
- 불필요한 알파 채널 제거
- UI 아틀라스 최적화

**오디오 최적화**:
- 압축 포맷 및 품질 설정
- 스트리밍 vs 메모리 로드 최적화
- 샘플레이트 조정
- 무음 구간 제거

#### 10.1.3 빌드 설정 최적화
**Unity 빌드 설정**:
- IL2CPP 백엔드 사용
- .NET Standard 2.1 호환성
- 코드 스트리핑 레벨 설정
- 압축 방식 LZ4HC 사용

**플랫폼별 최적화**:
- Android: ARM64 아키텍처 우선
- iOS: Bitcode 활성화
- 최소 지원 버전 설정
- 권한 요청 최소화

### 10.2 플랫폼별 설정

#### 10.2.1 Android 빌드 설정
**기본 설정**:
- Target API Level: 최신 요구사항 준수
- Minimum API Level: API 21 (Android 5.0)
- Scripting Backend: IL2CPP
- Target Architectures: ARM64 (ARMv7 선택적)

**성능 설정**:
- Multithreaded Rendering 활성화
- Graphics APIs: Vulkan, OpenGL ES 3
- Texture Compression: ASTC
- Audio Compression: Vorbis

**보안 및 권한**:
- Keystore 생성 및 서명
- 필요 권한만 요청 (WRITE_EXTERNAL_STORAGE 등)
- Network Security Config 설정
- ProGuard 설정 (난독화)

#### 10.2.2 iOS 빌드 설정
**기본 설정**:
- Target iOS Version: 12.0 이상
- Architecture: ARM64
- Scripting Backend: IL2CPP
- Camera Usage Description 등 필수 설명 추가

**성능 설정**:
- Metal Graphics API 사용
- Texture Compression: ASTC
- Audio Compression: MP3/AAC
- Stripping Level: Medium

**App Store 준비**:
- Bundle Identifier 설정
- 앱 아이콘 모든 해상도 준비
- Launch Screen 설정
- Privacy Policy URL 준비

### 10.3 테스트 및 QA

#### 10.3.1 기능 테스트
**핵심 기능 검증**:
- 전체 게임 플로우 완주 테스트
- Hero 시스템 모든 기능 검증
- 저장/로드 정확성 검증
- 모든 UI 상호작용 테스트

**에지 케이스 테스트**:
- 메모리 부족 상황 대응
- 네트워크 연결 불안정 상황
- 앱 백그라운드/포그라운드 전환
- 시스템 알림 중 게임 동작

#### 10.3.2 성능 테스트
**다양한 기기 테스트**:
- 저사양/중사양/고사양 기기별 성능
- 장시간 플레이 안정성
- 메모리 누수 여부 확인
- 배터리 소모량 측정

**스트레스 테스트**:
- 대량의 Hero 보유 상황
- 복잡한 UI 상태에서 성능
- 빠른 연속 조작 시 안정성
- 극한 상황 (골드 최대값 등) 처리

#### 10.3.3 사용성 테스트
**사용자 시나리오 테스트**:
- 신규 플레이어 첫 경험
- 복귀 플레이어 재적응
- 고급 플레이어 만족도
- 다양한 연령대 사용성

### 10.4 배포 및 출시 준비

#### 10.4.1 스토어 등록 준비
**메타데이터 준비**:
- 앱 이름 및 설명 (다국어)
- 키워드 및 카테고리 설정
- 스크린샷 및 프리뷰 영상
- 개인정보 처리방침

**심사 준비**:
- 가이드라인 준수 확인
- 인앱 구매 정책 준수 (해당시)
- 연령 등급 적절성 확인
- 테스트 계정 및 설명 준비

#### 10.4.2 마케팅 자료 준비
**시각 자료**:
- 앱 아이콘 (다양한 크기)
- 스크린샷 (게임의 핵심 재미 포인트)
- 프로모션 영상 (30초 이내)
- 소셜 미디어용 이미지